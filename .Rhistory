## but 41 zeros are coded as missing values (NA)
sum(is.na(geochem))
## no zeros:
which(geochem==0)
## we change the coding to zeros:
geochem[is.na(geochem)] <- 0
geochem <- geochem[,-3]
detect <- detect[-3]
z <- zeroPatterns(geochem)
z$tabcombPlus
colnames(geochem)
geochem <- geochem[,-15]
detect <- detect[-15]
z <- zeroPatterns(geochem)
z$tabcombPlus
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
geochem <- read.csv("~/Downloads/data_in.csv", header = TRUE)
w <- which(unlist(lapply(geochem, class)) != "numeric")
for(i in 1:ncol(geochem)) {
geochem[,i] <- as.numeric(geochem[,i])
}
## this detection limit should be given
## for each column to be present in the data to be
## replaced:
detect <- c(0.082,0.027,0.01,0.012,0.06,0.036,0.031,0.01,0.003)
len <- length(detect)
detect <- c(detect, rep(0,ncol(geochem) - len))
length(detect)
## it seems that there is no zeros in the data
## but 41 zeros are coded as missing values (NA)
sum(is.na(geochem))
## no zeros:
which(geochem==0)
## we change the coding to zeros:
geochem[is.na(geochem)] <- 0
### test g
geochem <- geochem[,-3]
detect <- detect[-3]
### test geochem,
z <- zeroPatterns(geochem)
z$tabcombPlus
geochem <- geochem[,-15]
detect <- detect[-15]
z <- zeroPatterns(geochem)
z$tabcombPlus
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
## to run the algorithm
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "MM", dl = detect,
verbose=TRUE)
## to run the algorithm
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "pls", dl = detect,
verbose=TRUE)
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
traceback()
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
phi
phi <- -isomLR(cbind(rep(dlordered[i], n), x[,-i,drop=FALSE]))[,1]
phi
phi
phi <- -isomLR(cbind(rep(dlordered[i], n), x[,-i,drop=FALSE]))[,1]
phi
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
s
mys
myphi
myreg1
myxilr
myx
x <- myx
xilr <- myxilr
phi <- myphi
s <- mys
ex <- myex
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
x <- myx
xilr <- myxilr
phi <- myphi
s <- mys
ex <- myex
dlordered <<- mydlordered
source('~/workspace/robCompositions-github/R/impRZilr.R')
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
x <- myx
xilr <- myxilr
phi <- myphi
s <- mys
ex <- myex
dlordered <<- mydlordered
indNA <- myindNA
source('~/workspace/robCompositions-github/R/impRZilr.R')
## to run the algorithm
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
x <- myx
xilr <- myxilr
phi <- myphi
s <- mys
ex <- myex
dlordered <- mydlordered
i <- myi
indNA <- myindNA
phi <- -isomLR(cbind(rep(dlordered[i], n), x[,-i,drop=FALSE]))[,1]
n <- nrow(x)
d <- ncol(x)
phi <- -isomLR(cbind(rep(dlordered[i], n), x[,-i,drop=FALSE]))[,1]
phi
y <- cbind(rep(dlordered[i], n), x[,-i,drop=FALSE])
head(y)
indNA
head(x,1)
x[,2]==0
x[,1]==0
which(x[,1]==0)
indNA <- apply(x, 2, function(x){any(is.na(x))})
indNA
x <- geochem
indNA <- apply(x, 2, function(x){any(is.na(x))})
indNA
x[x == 0] <- NA
x[x < 0] <- NA
indexFinalCheck <- is.na(x)
indNA <- apply(x, 2, function(x){any(is.na(x))})
indNA
cn <- colnames(x)
wcol <- - abs(apply(x, 2, function(x) sum(is.na(x))))
o <- order(wcol)
x <- x[,o]
dlordered <- dl[o]
w <- is.na(x)
wn <- !is.na(x)
xcheck <- x
w2 <- is.na(x)
indNA <- apply(x, 2, function(x){any(is.na(x))})
indNA
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
x <- myx
xilr <- myxilr
phi <- myphi
s <- mys
ex <- myex
dlordered <- mydlordered
i <- myi
indNA <- myindNA
indNA
geochem$Bi_0.02
geochem$Bi_0.02==0
geochem$Bi_0.02 < 0
any(geochem$Bi_0.02 < 0)
any(geochem$Bi_0.02 == 0)
any(is.na(geochem$Bi_0.02))
colnames(geochem)
x <- geochem
if( is.vector(x) ) stop("x must be a matrix or data frame")
## check if only numeric variables are in x:
cl <- lapply(x, class)
if(!all(cl %in% "numeric")) stop("some of your variables are not of class numeric.")
stopifnot((method %in% c("lm", "MM", "pls")))
if( length(dl) < ncol(x)) stop(paste("dl has to be a vector of ", ncol(x)))
dl <- detect
if( length(dl) < ncol(x)) stop(paste("dl has to be a vector of ", ncol(x)))
if(method=="pls" & ncol(x)<5) stop("too less variables/parts for method pls")
rs <- rowSums(x)
check <- logical(ncol(x))
for(i in 1:ncol(x)){
#      check[i] <- any(x[,i] < dl[i] & x[,i] != 0)
x[x[,i] < dl[i],i] <- 0
}
z <- zeroPatterns(x)
z$tabcombPlus
z <- zeroPatterns(geochem)
z$tabcombPlus
source('~/workspace/robCompositions-github/R/impRZilr.R')
## to run the algorithm
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
x <- myx
xilr <- myxilr
phi <- myphi
s <- mys
ex <- myex
dlordered <- mydlordered
i <- myi
indNA <- myindNA
z <- zeroPatterns(xx)
z$tabcombPlus
aggr(xx)
xxx <- xx
xxx[is.na(xxx)] <- NA
aggr(xx)
aggr(xxx)
a <- aggr(xxx)
plot(a)
dev.off()
xxx[xxx==0] <- NA
a <- aggr(xxx)
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
mydl
colnames(geochem)
colnames(xx)
geochem$LOI_
colnames(geochem)
geochem <- geochem[,-23]
detect <- detect[-23]
z <- zeroPatterns(geochem)
z$tabcombPlus
z <- zeroPatterns(geochem)
z$tabcombPlus
xx <- geochem
xx[xx==0] <- NA
aggr(xx)
geochem <- read.csv("~/Downloads/data_in.csv", header = TRUE)
w <- which(unlist(lapply(geochem, class)) != "numeric")
for(i in 1:ncol(geochem)) {
geochem[,i] <- as.numeric(geochem[,i])
}
## this detection limit should be given
## for each column to be present in the data to be
## replaced:
detect <- c(0.082,0.027,0.01,0.012,0.06,0.036,0.031,0.01,0.003)
len <- length(detect)
detect <- c(detect, rep(0,ncol(geochem) - len))
length(detect)
## it seems that there is no zeros in the data
## but 41 zeros are coded as missing values (NA)
sum(is.na(geochem))
## no zeros:
which(geochem==0)
## we change the coding to zeros:
geochem[is.na(geochem)] <- 0
### test geochem,
#
# for(i in 1:ncol(geochem)){
#   geochem[geochem[,i] < detect[i], i] <- NA
# }
# library(VIM)
# aggr(geochem)
# summary(geochem[,3]) # 98.2 % zeros
## we have to exclude Au_0.001, it makes
## no sense to work with a variable
## with more than 98 % zeros
geochem <- geochem[,-3]
detect <- detect[-3]
### test geochem,
z <- zeroPatterns(geochem)
z$tabcombPlus
## next problem:
## the 15'th varible contains a zero
## but we don't provide a detection limit
## for it. Will exclude this variable for replacement
## (alternatively, find a detectio limit for variable F_20)
geochem <- geochem[,-15]
detect <- detect[-15]
z <- zeroPatterns(geochem)
z$tabcombPlus
## next problem: LOI
## there are zeros in LOI,
## but the detection limit for LOI
## is 0. Must be changed (the detection limit)
## for now I exclude LOI_
geochem <- geochem[,-23]
detect <- detect[-23]
z <- zeroPatterns(geochem)
z$tabcombPlus
xx <- geochem
xx[xx==0] <- NA
aggr(xx)
## to run the algorithm
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
?impRZilr
head(x)
## store rowSums
rs <- rowSums(x)
#################
## zeros to NA:
# check if values are in (0, dl[i]):
check <- logical(ncol(x))
for(i in 1:ncol(x)){
#      check[i] <- any(x[,i] < dl[i] & x[,i] != 0)
x[x[,i] < dl[i],i] <- 0
}
#    if(any(check)){warning("values below detection limit have been set to zero and will be imputed")}
check2 <- any(x < 0)
if(check2){warning("values below 0 set have been set to zero and will be imputed")}
x[x == 0] <- NA
x[x < 0] <- NA
indexFinalCheck <- is.na(x)
################
## sort variables of x based on
## decreasing number of missings in the variables
cn <- colnames(x)
wcol <- - abs(apply(x, 2, function(x) sum(is.na(x))))
o <- order(wcol)
x <- x[,o]
if(verbose) cat("variables with decreasing number of missings:", o)
## --> now work in revised order of variables
## dl must also be in correct order
dlordered <- dl[o]
#################
## index of missings / non-missings
w <- is.na(x)
wn <- !is.na(x)
#    w2 <- apply(x, 1, function(x){ sum(is.na(x)) })
#	indNA <- apply(x, 2, function(x){any(is.na(x))})
#################
## sort the columns of the data according to the amount of missings in the variables
#    wcol <- apply(x, 2, function(x) length(which(is.na(x))))
#    indM <- sort(wcol, index.return=TRUE, decreasing=TRUE)$ix
xcheck <- x
w2 <- is.na(x)
colnames(x)
indNA <- apply(x, 2, function(x){any(is.na(x))})
print(indNA)
for(i in 1:length(dl)){
ind <- is.na(x[,i])
#		if(length(ind) > 0) x[ind,i] <- dl[i]*runif(sum(ind),1/3,2/3)
if(length(ind) > 0) x[ind,i] <- dlordered[i] *2/3
}
xOrig <- x
indNA
dlorderd[indNA]
dlordered[indNA]
geochem <- read.csv("~/Downloads/data_in.csv", header = TRUE)
w <- which(unlist(lapply(geochem, class)) != "numeric")
for(i in 1:ncol(geochem)) {
geochem[,i] <- as.numeric(geochem[,i])
}
## this detection limit should be given
## for each column to be present in the data to be
## replaced:
detect <- c(0.082,0.027,0.01,0.012,0.06,0.036,0.031,0.01,0.003)
len <- length(detect)
detect <- c(detect, rep(0,ncol(geochem) - len))
length(detect)
## it seems that there is no zeros in the data
## but 41 zeros are coded as missing values (NA)
sum(is.na(geochem))
## no zeros:
which(geochem==0)
## we change the coding to zeros:
geochem[is.na(geochem)] <- 0
### test geochem,
#
# for(i in 1:ncol(geochem)){
#   geochem[geochem[,i] < detect[i], i] <- NA
# }
# library(VIM)
# aggr(geochem)
# summary(geochem[,3]) # 98.2 % zeros
## we have to exclude Au_0.001, it makes
## no sense to work with a variable
## with more than 98 % zeros
geochem <- geochem[,-3]
detect <- detect[-3]
### test geochem,
z <- zeroPatterns(geochem)
z$tabcombPlus
## next problem:
## the 15'th varible contains a zero
## but we don't provide a detection limit
## for it. Will exclude this variable for replacement
## (alternatively, find a detectio limit for variable F_20)
geochem <- geochem[,-15]
detect <- detect[-15]
z <- zeroPatterns(geochem)
z$tabcombPlus
x <- geochem
if( is.vector(x) ) stop("x must be a matrix or data frame")
## check if only numeric variables are in x:
cl <- lapply(x, class)
if(!all(cl %in% "numeric")) stop("some of your variables are not of class numeric.")
stopifnot((method %in% c("lm", "MM", "pls")))
if( length(dl) < ncol(x)) stop(paste("dl has to be a vector of ", ncol(x)))
if(method=="pls" & ncol(x)<5) stop("too less variables/parts for method pls")
if(is.null(nComp)){
pre <- FALSE
nC <- NULL
} else if(nComp=="boot"){
nC <- integer(ncol(x))
pre <- TRUE
} else if(length(nComp) == ncol(x)){
nC <- nComp
pre <- FALSE
} else  {
pre <- FALSE
}
if(!(correction %in% c("normal","density"))) stop("correction method must be normal or density")
#     pre <- TRUE
#      if(length(nComp) != ncol(x) & nComp!="boot") stop("nComp must be NULL, boot or of length ncol(x)")
#    } else if(nComp == "boot"){#
#		pre <- TRUE
#	} else {
#		pre <- FALSE
#	}
#################
## store rowSums
rs <- rowSums(x)
#################
## zeros to NA:
# check if values are in (0, dl[i]):
check <- logical(ncol(x))
for(i in 1:ncol(x)){
#      check[i] <- any(x[,i] < dl[i] & x[,i] != 0)
x[x[,i] < dl[i],i] <- 0
}
#    if(any(check)){warning("values below detection limit have been set to zero and will be imputed")}
check2 <- any(x < 0)
if(check2){warning("values below 0 set have been set to zero and will be imputed")}
x[x == 0] <- NA
x[x < 0] <- NA
indexFinalCheck <- is.na(x)
################
## sort variables of x based on
## decreasing number of missings in the variables
cn <- colnames(x)
wcol <- - abs(apply(x, 2, function(x) sum(is.na(x))))
o <- order(wcol)
x <- x[,o]
if(verbose) cat("variables with decreasing number of missings:", o)
## --> now work in revised order of variables
## dl must also be in correct order
dlordered <- dl[o]
#################
## index of missings / non-missings
w <- is.na(x)
wn <- !is.na(x)
#    w2 <- apply(x, 1, function(x){ sum(is.na(x)) })
#	indNA <- apply(x, 2, function(x){any(is.na(x))})
#################
## sort the columns of the data according to the amount of missings in the variables
#    wcol <- apply(x, 2, function(x) length(which(is.na(x))))
#    indM <- sort(wcol, index.return=TRUE, decreasing=TRUE)$ix
xcheck <- x
w2 <- is.na(x)
################
## initialisation
indNA <- apply(x, 2, function(x){any(is.na(x))})
print(indNA)
for(i in 1:length(dl)){
ind <- is.na(x[,i])
#		if(length(ind) > 0) x[ind,i] <- dl[i]*runif(sum(ind),1/3,2/3)
if(length(ind) > 0) x[ind,i] <- dlordered[i] *2/3
}
xOrig <- x
dlordered[indNA]
w <- which(dlordered[indNA]==0)
w
colnames(x)[w]
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
source('~/workspace/robCompositions-github/R/impRZilr.R')
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
warnings()
?warning
source('~/workspace/robCompositions-github/R/impRZilr.R')
## to run the algorithm
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
source('~/workspace/robCompositions-github/R/impRZilr.R')
finalGeochem <- impRZilr(geochem, maxit = 1, eps = 0.1,
method = "lm", dl = detect,
verbose=TRUE)
getwd()
bootnComp
prompt("bootnComp")
prompt(bootnComp)
