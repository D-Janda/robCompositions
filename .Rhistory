## sort variables of x based on
## decreasing number of missings in the variables
cn <- colnames(x)
wcol <- - abs(apply(x, 2, function(x) sum(is.na(x))))
o <- order(wcol)
x <- x[,o]
if(verbose) cat("variables with decreasing number of missings:", o)
## --> now work in revised order of variables
## dl must also be in correct order
dlordered <- dl[o]
#################
## index of missings / non-missings
w <- is.na(x)
wn <- !is.na(x)
#    w2 <- apply(x, 1, function(x){ sum(is.na(x)) })
#	indNA <- apply(x, 2, function(x){any(is.na(x))})
#################
## sort the columns of the data according to the amount of missings in the variables
#    wcol <- apply(x, 2, function(x) length(which(is.na(x))))
#    indM <- sort(wcol, index.return=TRUE, decreasing=TRUE)$ix
xcheck <- x
w2 <- is.na(x)
################
## initialisation
indNA <- apply(x, 2, function(x){any(is.na(x))})
print(indNA)
for(i in 1:length(dl)){
ind <- is.na(x[,i])
#		if(length(ind) > 0) x[ind,i] <- dl[i]*runif(sum(ind),1/3,2/3)
if(length(ind) > 0) x[ind,i] <- dlordered[i] *2/3
}
xOrig <- x
################
## check if for any variable with zeros,
## the detection limit should be larger than 0:
if(any(dlordered[indNA]==0)){
w <- which(dlordered[indNA]==0)
invalidCol <- colnames(x)[w]
for(i in 1:length(invalidCol)){
cat("-------\n")
cat(paste("Error: variable/part", invalidCol[i],
"has detection limit 0 but includes zeros"))
cat("\n-------\n")
}
stop(paste("Set detection limits larger than 0 for variables/part \n including zeros"))
}
################
n <- nrow(x)
d <- ncol(x)
###  start the iteration
if(verbose) cat("\n start the iteration:")
it <- 1; criteria <- 99999999
if(verbose) cat("\n iteration", it, "; criteria =", criteria)
xold <- x
for(i in which(indNA)){
if(verbose) cat("\n replacement on part", i)
## detection limit in ilr-space
phi <- -isomLR(cbind(rep(dlordered[i], n), x[,-i,drop=FALSE]))[,1]
#		part <- cbind(x[,i,drop=FALSE], x[,-i,drop=FALSE])
x[x < 2*.Machine$double.eps] <- 2*.Machine$double.eps
xilr <- data.frame(-isomLR(cbind(x[,i,drop=FALSE], x[,-i,drop=FALSE])))
c1 <- colnames(xilr)[1]
colnames(xilr)[1] <- "V1"
response <- as.matrix(xilr[,1,drop=FALSE])
predictors <- as.matrix(xilr[,-1,drop=FALSE])
if(method=="lm"){
reg1 <- lm(response ~ predictors)
yhat <- predict(reg1, new.data=data.frame(predictors))
} else if(method=="MM"){
reg1 <- rlm(response ~ predictors, method="MM",maxit = 100)#rlm(V1 ~ ., data=xilr2, method="MM",maxit = 100)
yhat <- predict(reg1, new.data=data.frame(predictors))
} else if(method=="pls"){
if(it == 1 & pre){ ## evaluate ncomp.
nC[i] <- bootnComp(xilr[,!(colnames(xilr) == "V1"),drop=FALSE],y=xilr[,"V1"], R,
plotting=FALSE)$res #$res2
}
if(verbose) cat("   ;   ncomp:",nC[i])
reg1 <- mvr(as.matrix(response) ~ as.matrix(predictors), ncomp=nC[i], method="simpls")
yhat <- predict(reg1, new.data=data.frame(predictors), ncomp=nC[i])
}
#		s <- sqrt(sum(reg1$res^2)/abs(nrow(xilr)-ncol(xilr))) ## quick and dirty: abs()
s <- sqrt(sum(reg1$res^2)/nrow(xilr))
ex <- (phi - yhat)/s
if(correction=="normal"){
yhat2sel <- ifelse(dnorm(ex[w[, i]]) > .Machine$double.eps,
yhat[w[, i]] - s*dnorm(ex[w[, i]])/pnorm(ex[w[, i]]),
yhat[w[, i]])
} else if(correction=="density"){
den <- density(ex[w[,i]])
distr <- kCDF(ex[w,i])
}
if(any(is.na(yhat)) || any(yhat=="Inf")) stop("Problems in ilr because of infinite or NA estimates")
# check if we are under the DL:
if(any(yhat2sel >= phi[w[, i]])){
yhat2sel <- ifelse(yhat2sel > phi[w[, i]], phi[w[, i]], yhat2sel)
}
xilr[w[, i], 1] <- yhat2sel
xinv <- isomLRinv(-xilr)
## reordering of xOrig
if(i %in% 2:(d-1)){
xinv <- cbind(xinv[,2:i], xinv[,c(1,(i+1):d)])
}
if(i == d){
xinv <- cbind(xinv[,2:d], xinv[,1])
}
#       browser()
x <- adjustImputed(xinv, xOrig, w2)
#		x <- adjust3(xinv, xOrig, w2)
#		## quick and dirty:
#		x[!w] <- xOrig[!w]
}
phi
summary(phi)
x <- geochem
maxit=10
eps=0.1
method="lm"
dl=detect
nComp = "boot"
bruteforce=FALSE
noisemethod="residuals"
noise=FALSE
R=10
correction="normal"
verbose=TRUE
if( is.vector(x) ) stop("x must be a matrix or data frame")
## check if only numeric variables are in x:
cl <- lapply(x, class)
if(!all(cl %in% "numeric")) stop("some of your variables are not of class numeric.")
stopifnot((method %in% c("lm", "MM", "pls")))
if( length(dl) < ncol(x)) stop(paste("dl has to be a vector of ", ncol(x)))
if(method=="pls" & ncol(x)<5) stop("too less variables/parts for method pls")
if(is.null(nComp)){
pre <- FALSE
nC <- NULL
} else if(nComp=="boot"){
nC <- integer(ncol(x))
pre <- TRUE
} else if(length(nComp) == ncol(x)){
nC <- nComp
pre <- FALSE
} else  {
pre <- FALSE
}
if(!(correction %in% c("normal","density"))) stop("correction method must be normal or density")
#     pre <- TRUE
#      if(length(nComp) != ncol(x) & nComp!="boot") stop("nComp must be NULL, boot or of length ncol(x)")
#    } else if(nComp == "boot"){#
#		pre <- TRUE
#	} else {
#		pre <- FALSE
#	}
#################
## store rowSums
rs <- rowSums(x)
#################
## zeros to NA:
# check if values are in (0, dl[i]):
check <- logical(ncol(x))
for(i in 1:ncol(x)){
#      check[i] <- any(x[,i] < dl[i] & x[,i] != 0)
x[x[,i] < dl[i],i] <- 0
}
#    if(any(check)){warning("values below detection limit have been set to zero and will be imputed")}
check2 <- any(x < 0)
if(check2){warning("values below 0 set have been set to zero and will be imputed")}
x[x == 0] <- NA
x[x < 0] <- NA
indexFinalCheck <- is.na(x)
################
## sort variables of x based on
## decreasing number of missings in the variables
cn <- colnames(x)
wcol <- - abs(apply(x, 2, function(x) sum(is.na(x))))
o <- order(wcol)
x <- x[,o]
if(verbose) cat("variables with decreasing number of missings:", o)
## --> now work in revised order of variables
## dl must also be in correct order
dlordered <- dl[o]
#################
## index of missings / non-missings
w <- is.na(x)
wn <- !is.na(x)
#    w2 <- apply(x, 1, function(x){ sum(is.na(x)) })
#	indNA <- apply(x, 2, function(x){any(is.na(x))})
#################
## sort the columns of the data according to the amount of missings in the variables
#    wcol <- apply(x, 2, function(x) length(which(is.na(x))))
#    indM <- sort(wcol, index.return=TRUE, decreasing=TRUE)$ix
xcheck <- x
w2 <- is.na(x)
################
## initialisation
indNA <- apply(x, 2, function(x){any(is.na(x))})
print(indNA)
for(i in 1:length(dl)){
ind <- is.na(x[,i])
#		if(length(ind) > 0) x[ind,i] <- dl[i]*runif(sum(ind),1/3,2/3)
if(length(ind) > 0) x[ind,i] <- dlordered[i] *2/3
}
xOrig <- x
################
## check if for any variable with zeros,
## the detection limit should be larger than 0:
if(any(dlordered[indNA]==0)){
w <- which(dlordered[indNA]==0)
invalidCol <- colnames(x)[w]
for(i in 1:length(invalidCol)){
cat("-------\n")
cat(paste("Error: variable/part", invalidCol[i],
"has detection limit 0 but includes zeros"))
cat("\n-------\n")
}
stop(paste("Set detection limits larger than 0 for variables/part \n including zeros"))
}
################
n <- nrow(x)
d <- ncol(x)
###  start the iteration
if(verbose) cat("\n start the iteration:")
it <- 1; criteria <- 99999999
if(verbose) cat("\n iteration", it, "; criteria =", criteria)
xold <- x
for(i in which(indNA)){
if(verbose) cat("\n replacement on part", i)
## detection limit in ilr-space
forphi <- cbind(rep(dlordered[i], n), x[,-i,drop=FALSE])
if(any(is.na(forphi))) break()
phi <- -isomLR(forphi)[,1]
#		part <- cbind(x[,i,drop=FALSE], x[,-i,drop=FALSE])
x[x < 2*.Machine$double.eps] <- 2*.Machine$double.eps
xilr <- data.frame(-isomLR(cbind(x[,i,drop=FALSE], x[,-i,drop=FALSE])))
c1 <- colnames(xilr)[1]
colnames(xilr)[1] <- "V1"
response <- as.matrix(xilr[,1,drop=FALSE])
predictors <- as.matrix(xilr[,-1,drop=FALSE])
if(method=="lm"){
reg1 <- lm(response ~ predictors)
yhat <- predict(reg1, new.data=data.frame(predictors))
} else if(method=="MM"){
reg1 <- rlm(response ~ predictors, method="MM",maxit = 100)#rlm(V1 ~ ., data=xilr2, method="MM",maxit = 100)
yhat <- predict(reg1, new.data=data.frame(predictors))
} else if(method=="pls"){
if(it == 1 & pre){ ## evaluate ncomp.
nC[i] <- bootnComp(xilr[,!(colnames(xilr) == "V1"),drop=FALSE],y=xilr[,"V1"], R,
plotting=FALSE)$res #$res2
}
if(verbose) cat("   ;   ncomp:",nC[i])
reg1 <- mvr(as.matrix(response) ~ as.matrix(predictors), ncomp=nC[i], method="simpls")
yhat <- predict(reg1, new.data=data.frame(predictors), ncomp=nC[i])
}
#		s <- sqrt(sum(reg1$res^2)/abs(nrow(xilr)-ncol(xilr))) ## quick and dirty: abs()
s <- sqrt(sum(reg1$res^2)/nrow(xilr))
ex <- (phi - yhat)/s
if(correction=="normal"){
yhat2sel <- ifelse(dnorm(ex[w[, i]]) > .Machine$double.eps,
yhat[w[, i]] - s*dnorm(ex[w[, i]])/pnorm(ex[w[, i]]),
yhat[w[, i]])
} else if(correction=="density"){
den <- density(ex[w[,i]])
distr <- kCDF(ex[w,i])
}
if(any(is.na(yhat)) || any(yhat=="Inf")) stop("Problems in ilr because of infinite or NA estimates")
# check if we are under the DL:
if(any(yhat2sel >= phi[w[, i]])){
yhat2sel <- ifelse(yhat2sel > phi[w[, i]], phi[w[, i]], yhat2sel)
}
xilr[w[, i], 1] <- yhat2sel
xinv <- isomLRinv(-xilr)
## reordering of xOrig
if(i %in% 2:(d-1)){
xinv <- cbind(xinv[,2:i], xinv[,c(1,(i+1):d)])
}
if(i == d){
xinv <- cbind(xinv[,2:d], xinv[,1])
}
#       browser()
x <- adjustImputed(xinv, xOrig, w2)
#		x <- adjust3(xinv, xOrig, w2)
#		## quick and dirty:
#		x[!w] <- xOrig[!w]
}
summary(forphi)
which(is.na(x[,1]))
dim(x)
x[2532,]
geochem[2532,]
dl
detect =c(0.079,0.027,0.009,0.013,0.048,0.046,0.024,35,0.015)
names(detect) <- colnames(geochem)
detect["SO4_ppm"] <- 0.5
summary(geochem[,"Br_ppm"])
detect["Br_ppm"] <- 0.0034
geochem <- geochem[-2532,]
finalGeochem <- impRZilr(geochem, maxit = 10, eps = 0.1, method = "lm",
dl = detect, verbose=TRUE)
detect =c(0.079,0.027,0.009,0.013,0.048,0.046,0.024,35,0.015)
names(detect) <- colnames(geochem)
# 100% under DL in SO4_ppm
# set artificial DL:
detect["SO4_ppm"] <- 0.5
# approx 90% under DL in Br_ppm
# summary(geochem[,"Br_ppm"])
# detect["Br_ppm"] <- 0.0034
geochem <- geochem[-2532,]
x <- geochem
maxit=10
eps=0.1
method="lm"
dl=detect
nComp = "boot"
bruteforce=FALSE
noisemethod="residuals"
noise=FALSE
R=10
correction="normal"
verbose=TRUE
if( is.vector(x) ) stop("x must be a matrix or data frame")
## check if only numeric variables are in x:
cl <- lapply(x, class)
if(!all(cl %in% "numeric")) stop("some of your variables are not of class numeric.")
stopifnot((method %in% c("lm", "MM", "pls")))
if( length(dl) < ncol(x)) stop(paste("dl has to be a vector of ", ncol(x)))
if(method=="pls" & ncol(x)<5) stop("too less variables/parts for method pls")
if(is.null(nComp)){
pre <- FALSE
nC <- NULL
} else if(nComp=="boot"){
nC <- integer(ncol(x))
pre <- TRUE
} else if(length(nComp) == ncol(x)){
nC <- nComp
pre <- FALSE
} else  {
pre <- FALSE
}
if(!(correction %in% c("normal","density"))) stop("correction method must be normal or density")
#     pre <- TRUE
#      if(length(nComp) != ncol(x) & nComp!="boot") stop("nComp must be NULL, boot or of length ncol(x)")
#    } else if(nComp == "boot"){#
#		pre <- TRUE
#	} else {
#		pre <- FALSE
#	}
#################
## store rowSums
rs <- rowSums(x)
#################
## zeros to NA:
# check if values are in (0, dl[i]):
check <- logical(ncol(x))
for(i in 1:ncol(x)){
#      check[i] <- any(x[,i] < dl[i] & x[,i] != 0)
x[x[,i] < dl[i],i] <- 0
}
#    if(any(check)){warning("values below detection limit have been set to zero and will be imputed")}
check2 <- any(x < 0)
if(check2){warning("values below 0 set have been set to zero and will be imputed")}
x[x == 0] <- NA
x[x < 0] <- NA
indexFinalCheck <- is.na(x)
checkRows <- unlist(apply(x, 1, function(x) all(is.na(x))))
checkRows
any(checkRows)
x[2532,]
dl
library(robustbase)
library(rrcov)
library(pcaPP)
library(mvtnorm)
library(car)
library(MASS)
library(pls)
library(robCompositions)
geochem <- read.csv("~/Downloads/data_in_Med_Br.csv", header = TRUE)
geochem <- as.matrix(geochem)
detect =c(0.079,0.027,0.009,0.013,0.048,0.046,0.024,35,0.015)
names(detect) <- colnames(geochem)
# 100% under DL in SO4_ppm
# set artificial DL:
detect["SO4_ppm"] <- 0.5
# approx 90% under DL in Br_ppm
# summary(geochem[,"Br_ppm"])
# detect["Br_ppm"] <- 0.0034
x <- geochem
maxit=10
eps=0.1
method="lm"
dl=detect
nComp = "boot"
bruteforce=FALSE
noisemethod="residuals"
noise=FALSE
R=10
correction="normal"
verbose=TRUE
if( is.vector(x) ) stop("x must be a matrix or data frame")
## check if only numeric variables are in x:
cl <- lapply(x, class)
if(!all(cl %in% "numeric")) stop("some of your variables are not of class numeric.")
stopifnot((method %in% c("lm", "MM", "pls")))
if( length(dl) < ncol(x)) stop(paste("dl has to be a vector of ", ncol(x)))
if(method=="pls" & ncol(x)<5) stop("too less variables/parts for method pls")
if(is.null(nComp)){
pre <- FALSE
nC <- NULL
} else if(nComp=="boot"){
nC <- integer(ncol(x))
pre <- TRUE
} else if(length(nComp) == ncol(x)){
nC <- nComp
pre <- FALSE
} else  {
pre <- FALSE
}
if(!(correction %in% c("normal","density"))) stop("correction method must be normal or density")
#     pre <- TRUE
#      if(length(nComp) != ncol(x) & nComp!="boot") stop("nComp must be NULL, boot or of length ncol(x)")
#    } else if(nComp == "boot"){#
#		pre <- TRUE
#	} else {
#		pre <- FALSE
#	}
#################
## store rowSums
rs <- rowSums(x)
#################
## zeros to NA:
# check if values are in (0, dl[i]):
check <- logical(ncol(x))
for(i in 1:ncol(x)){
#      check[i] <- any(x[,i] < dl[i] & x[,i] != 0)
x[x[,i] < dl[i],i] <- 0
}
#    if(any(check)){warning("values below detection limit have been set to zero and will be imputed")}
check2 <- any(x < 0)
if(check2){warning("values below 0 set have been set to zero and will be imputed")}
x[x == 0] <- NA
x[x < 0] <- NA
indexFinalCheck <- is.na(x)
checkRows <- unlist(apply(x, 1, function(x) all(is.na(x))))
checkRows
any(checkRows)
w <- which(checkRows)
w
stop(paste("Following rows with only zeros:", ))
stop(paste("Following rows with only zeros:", w))
geochem <- read.csv("~/Downloads/data_in_Med_Br.csv", header = TRUE)
geochem <- as.matrix(geochem)
detect =c(0.079,0.027,0.009,0.013,0.048,0.046,0.024,35,0.015)
names(detect) <- colnames(geochem)
# 100% under DL in SO4_ppm
# set artificial DL:
detect["SO4_ppm"] <- 0.5
# approx 90% under DL in Br_ppm
# summary(geochem[,"Br_ppm"])
# detect["Br_ppm"] <- 0.0034
geochem <- geochem[-2532,]
finalGeochem <- impRZilr(geochem, maxit = 3,
eps = 1, method = "lm",
dl = detect, verbose=TRUE)
library(devtools)
install_github("robCompositions","matthias-da")
packageDescription("robCompositions")
detach(pa=robCompositions)
detach(package:robCompositions)
library(devtools)
install_github("robCompositions","matthias-da")
library(robCompositions)
source('~/workspace/robCompositions-github/R/impRZilr.R')
library(robustbase)
library(rrcov)
library(pcaPP)
library(mvtnorm)
library(car)
library(MASS)
library(pls)
library(robCompositions)
## change path accordingly:
geochem <- read.csv("~/Downloads/data_in_Med_Br.csv", header = TRUE)
geochem <- as.matrix(geochem)
detect =c(0.079,0.027,0.009,0.013,0.048,0.046,0.024,35,0.015)
names(detect) <- colnames(geochem)
# 100% under DL in SO4_ppm
# set artificial DL:
detect["SO4_ppm"] <- 0.5
# approx 90% under DL in Br_ppm
# summary(geochem[,"Br_ppm"])
# detect["Br_ppm"] <- 0.0034
geochem <- geochem[-2532,]
finalGeochem <- impRZilr(geochem, maxit = 3,
eps = 1, method = "lm",
dl = detect, verbose=TRUE)
source('~/workspace/robCompositions-github/R/impRZilr.R')
## change path accordingly:
geochem <- read.csv("~/Downloads/data_in_Med_Br.csv", header = TRUE)
geochem <- as.matrix(geochem)
detect =c(0.079,0.027,0.009,0.013,0.048,0.046,0.024,35,0.015)
names(detect) <- colnames(geochem)
# 100% under DL in SO4_ppm
# set artificial DL:
detect["SO4_ppm"] <- 0.5
# approx 90% under DL in Br_ppm
# summary(geochem[,"Br_ppm"])
# detect["Br_ppm"] <- 0.0034
geochem <- geochem[-2532,]
finalGeochem <- impRZilr(geochem, maxit = 3,
eps = 1, method = "lm",
dl = detect, verbose=TRUE)
library(robCompositions)
library(robCompositions)
